Choix de la stategie de Mapping Objet relationnel:

Oeuvre -> Peinture / Sculpture / Photographie

Nous avons choisi de prendre la stratÃ©gie SINGLE TABLE du fait que les insertions et requÃªtes de selection ne sont pas couteuses. Quelques attributs 
des classes filles (Photographie, peinture, ..) sont rajoutÃ©s dans la classe mÃ¨re (ils sont peu nombreux), quelques attributs sont specifiques Ã  une classe fille ce qui
implique qu'ils ne seront pas renseignes pour certaines classes concrÃ¨tes.

Nous n'avons pas choisi la methode TABLE_PER_CLASS car cela impliquerait de devoir dupliquer les informations de la classe mere dans chacune de ses classes concrÃ¨tes.
Au niveau des requÃ¨tes de selection sur la classe mÃ¨re cela les alourdit en creant des jointures pour acceder aux classes concrÃ¨tes (ex : le conservateur veut connaitre
toutes les oeuvres d'une collection ==> Comme on a persiste que les classes concretes, on est obligÃ© de faire une jointure entre toutes les classes concrÃ¨tes).

Nous n'avons pas egalement choisi la methode JOINED bien qu'elle proche du modÃ¨le objet car cela alourdit les insertions en base (2 requetes par insertion, insÃ©rer 
d'abord les information dans la classe mÃ¨re puis dans la classe fille ) et les requÃ¨tes.



Personne -> Libraire / Conservateur / artiste

Nous avons choisi la stategie TABLE PER CLASS afin de rentrer en base les classes concretes. En effet nous n'aurons pas besoin d'effectuer de requÃ¨tes (jointures)
 pour recolter des informations sur un ensemble de personnes.

----------------------------------------------------------------------------------------------------------------------------------------------------------

CARDINALITES

Oeuvre et reproduction :
==> OneToOne unidirectionnel
Une reproduction connait l'oeuvre qu'elle reproduit, tandis qu'une oeuvre n'est pas consciente de ses reproductions.
Une oeuvre peut avoir plusieurs reproductions, une reproduction ne reproduit qu'une oeuvre.


Collection et oeuvre :
==> n:m ManyToMany unidirectionnel
Une oeuvre ne sait pas qu'elle est dans une collection, une collection connait toutes les oeuvres qu'elle contient.
Une collection possede une ou plusieurs oeuvres, une oeuvre peut appartenir a plusieurs collections.


Oeuvre et artiste :
=> 1:1 unidirectionnel
Une oeuvre sait par quel artiste elle a ete faite, tandis qu'un artiste n'est pas conscient de ses oeuvres.
Une oeuvre possede une cle etrangere sur Artiste (JoinColumn)
Une oeuvre est faite par un artiste, un artiste peut faire plusieurs oeuvres.
! : Il faut d'abord persister un Artiste dans la base avant de persister une oeuvre, sinon l'oeuvre reference une entite non presente en base.
? : utiliser cascade.PERSIST ? n'a pas encore marche

----------------------------------------------------------------------------------------------------------------------------------------------------------

DEPOT HIBERNATE :
http://mvnrepository.com/artifact/org.hibernate/hibernate-core/4.1.7.Final

 ! : trouver des tuto a jour (Hibernate 4) car les precedents n'utilisent pas d'annotations mais plutot des fichiers de mapping.
 

 
 Pour persister les donnees, on peut soit utiliser les EntityManager (avec persist()), soit utiliser une session (qui est specifique Ã  hibernate) et faire un save().
 Il peut etre judicieux d'utiliser l'API JPA (standard JEE ==> augmente la portabilite du projet. ex : si on change de framework de persistence, on n'a pas de changement
 a  faire) plutot que celle d'hibernate (A nous de choisir).
 
---------
 Citation de Stackoverflow :
 The EntityManager invokes the hibernate session under the hood. And if you need some specific features that are not available in the EntityManager,
  you can obtain the session by calling:Session session = entityManager.unwrap(Session.class);
---------

au lieu de creer une classe HibernateUtil nous avons cree la classe JPAUtil

Pour configurer Hibernate il est possible de le faire via le fichier hibernate.cfg.xml ou persistence.xml => nous avons choisi persistence.xml
etant donné que nous utilisons l'API de JPA


 ! : a la version de dependance hibernate-entitymanager, celle qu'on avait : Hibernate EntityManager 3.3.0.GA n'est pas une implementation de
 JPA 2.0  (alors que dans notre persistence.xml on a :  http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd" version="2.0") et ne supporte 
 donc pas javax.persistence.*
 Nous avons donc pris la version : 3.5.1-Final et ca marche (plus d'erreur : the user must supply a jdbc connection).


----------------------------------------------------------------------------------------------------------------------------------------------------------

Utilisation d'Enums pour Support / Realisation / Etat / Materiaux
=> Faire constructeur avec param et par defaut, ajouter l'annotation @Enumerated(EnumType.STRING) au dessus des champs dans les classes 
les utilisant

---------------------------------------------------------------------------------------------------------------------------------------------------------- 

Tests DAO

!: Attention, il faut set tous les attribut d'un objet pour qu'il soit persiste dans la base (sauf s'ils ont l'annotation @Column(nullable=true)).
Passer par les setter ou le constructeur avec parametre.

Il etait prevu d'utiliser une base de donnees embarquee type h2db comme en TD mais en la mettant en place nous avons eu quelques problemes.
Alors que les donnees sont correctement persistees en base avec MySQL, un grand nombre d'erreurs apparaissent avec H2DB. Il a donc ete
decide d'utiliser MySQL pour les tests => Une base de donnees de test a ete cree pour l'occasion "museeTest", en plus de la base "musee".
Pour cela un fichier persitence.xml existe dans src/main/resources et src/test/resources afin de configurer les 2 bases (elles sont similaires,
seul le nom change).

---------------------------------------------------------------------------------------------------------------------------------------------------------- 
LOGGERS

dans le fichier log4j.properties, le niveau des log d'hibernate a ete reduit a ERROR pour ne pas polluer l'affichage :
log4j.logger.org.hibernate = ERROR

Nos LOGs faits dans nos classes ont le niveau ALL afin de ne rien rater.

Ainsi lorsque l'on lance mvn clean install, on a les erreurs d'hibernate / nos logs / les requetes SQL grace à <property name="hibernate.show_sql" value="true" />


---------------------------------------------------------------------------------------------------------------------------------------------------------- 


